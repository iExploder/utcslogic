# Variable-length Parameter List for OCaml Type

## Story from the development of Wagon
### What is Wagon?
Wagon is designed as an embedded DSL for OCaml, in order to reduce misuse of Intel SIMD(Single Instruction Multiple Data) Intrinsics by enhancing type check and type inference.
C codes with Intel SIMD Intrinsics are intended to be generated by Wagon module.

Intel SIMD Intrinsics are designed for experienced C/C++ programmers,
with SIMD instructions encapsulated as declarations of C structures and C functions.

The main data types, `__m128i`, `__m256i`, `__m512i` for integers,
`__m128`, `__m256`, `__m512` for single-precision floating decimals,
and `__m128d`, `__m256d`, `__m512d` for double-precision floating decimals.
(512-bit vectors only available on enterprise market Xeon E5/E7 and consumer market architectures starting from Ice Lake(10th gen Core processors))

There is almost no problem for `float` and `double` vectors since they are just specially aligned arrays holding only **one** type of data.

For integer vectors, the declarations are listed below.

---
**Code 1**: Declaration of Integer SIMD Vectors 
```c
/* From <immintrin.h> */
typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;
/* From <zmmintrin.h> */
typedef union  __declspec(intrin_type) __declspec(align(64)) __m512i {
    __int8              m512i_i8[64];
    __int16             m512i_i16[32];
    __int32             m512i_i32[16];
    __int64             m512i_i64[8];
    unsigned __int8     m512i_u8[64];
    unsigned __int16    m512i_u16[32];
    unsigned __int32    m512i_u32[16];
    unsigned __int64    m512i_u64[8];
} __m512i;
```
---
The type safety problem is significant.
Integers are held in the same type of union structure regardless of the bit length.
That means, programmer must keep the element type of integer vectors in their mind rather than checked by the compiler.

**Wagon** is designed to avoid the misuse cases similar to the case above.

In the design of type system of Wagon, tagless-final style introduced by Oleg Kiseloyv is designed to be used for simplicity and gracefulness.
However, in code representation of C-style structures in which different types of elements could take place.

---
**Code 2**: Extreme usage of C-style structure
```c
struct MyStruct1
{
    int32_t var1;
    int64_t var2;
    float   arr1[64];
    __m128d vec1;
    __m256i vecarr1[32];
};

struct MyStruct2
{
    int32_t          var1;
    int64_t          var2;
    struct MyStruct1 str1;
    float            var3;
    int32_t          arr1[32];
    bool             var4;
    __m128i          vec1;
    __m256           vecarr1[64];
};
```
---
## Type representation in Wagon(insufficient)

For operators of 
* `EXTRACTHI`: Get higher address half of vectors
* `HIWORD`: Get higher 16-bit part of a `DWORD`(32-bit) integer
* ...
,

type inference of half and double is implemented by

**Code 3-1**: Wagon Types Definition
```ocaml
type 'a x2
type i8
type i16 = i8 x2
(* ... *)
type 'a ityp
type 'a v128i
type 'a v256i = 'a v128i x2
type 'a v512i = 'a v256i x2
type 'a vec
(* ... *)

(* abbr: string;    fullname: string; *)
(* bitsize: int;    align   : int     *)
type 'a wtype = string * string * int * int
```
Notice: internal representation of `string * string * int * int` is designed invisible to users of **Wagon** language.

So that type inference of double and half could be

**Code 3-2**: Wagon Type Inferences
```ocaml
val doublei : 'a ityp wtype    -> 'a x2 ityp wtype
val halfi   : 'a x2 ityp wtype -> 'a ityp wtype
val doublev : 'a vec wtype     -> 'a x2 vec wtype
val halfv   : 'a x2 vec wtype  -> 'a vec wtype
```

Unfortunately, this implementation is insuficient for full-feature C language term representation.

## Problem from `struct`

The temporary implementation of C-style structure `struct` in Wagon
is shown below.
```ocaml
type structure
val structure : 'a wtype list -> structure wtype
```
The problem is how to represent a structure in form of
`string * string * int * int` with preserving types inside the `struct`.

## Proposal for an OCaml Extension

### Type List of OCaml

In order to access n-th element in the `struct`,
implementing `struct` with tuple in OCaml,
hard-coded types and functions necessary are shown below.

---
**Code 4-1**: Hard-coded style `struct` element access
```ocaml
type ('a) t1 = 'a
type ('a, 'b) t2 = 'a * 'b
type ('a, 'b, 'c) t3 = 'a * 'b * 'c
(* ... *)

val t1_0 : ('a) t1 -> 'a
val t2_0 : ('a, 'b) t2 -> 'a
val t2_1 : ('a, 'b) t2 -> 'b
val t3_0 : ('a, 'b, 'c) t3 -> 'a
val t3_1 : ('a, 'b, 'c) t3 -> 'b
val t3_2 : ('a, 'b, 'c) t3 -> 'c
(* ... *)
```
---
**Code 4-2**: Recursive style `struct` element access
```ocaml
type ('a) t1 = 'a
type ('a, 'b) t2 = 'a * 'b
type ('a, 'b, 'c) t3 = 'a * 'b * 'c
(* ... *)

val t1_hd : ('a) t1 -> 'a
val t2_hd : ('a, 'b) t2 -> 'a
val t3_hd : ('a, 'b, 'c) t3 -> 'a
val t1_tl : unit
val t2_tl : ('a, 'b) t2 -> ('b) t1
val t3_tl : ('a, 'b, 'c) t3 -> ('b, 'c) t2
(* ... *)
```
---

So that every element in a struct is accessable.
However, the code is neither graceful nor simple.
With the increasing number of elements in a `struct`,
manually writing every necessary branch of type definitions and
functions is boring and easily mistaken.

Above all, a proposal for extending the syntax of OCaml is on its roadmap.

---
**Code 4-3**: Example for proposal of variable-length type parameter list
```ocaml
(* Variable-length parameter list ('a, ...) in OCaml list style *)
type ('a, 'tl) vt = 'a @* ('tl vt)
(* @* means *-linking without scope *)
(* So that (int, float, bool) vt is (int * float * bool) *)

(* 'a 'vtuple <=> ('a 't, 'tl) vt *)

let vt_hd : ('a, 'tl) vt -> 'a =
    fun vt -> Vtuple.hd vt
let vt_nth : ('a, 'tl) vt -> int -> 'le = (* 'le: List Element *)
    fun vt n -> Vtuple.nth vt n
```
---
Then the **Wagon** structure could be implemented as below.

---
**Code 4-4**: Wagon structure implementation with extended OCaml
```ocaml
type ('a wtype, 'tl) structure = 'a wtype @* ('tl structure)
let str_hd : ('a, 'tl) structure -> 'a =
    fun vt -> Vtuple.hd vt
let str_nth : ('a, 'tl) structure -> int -> 'le =
    fun vt n -> Vtuple.nth vt n
let structure : ('a wtype) 'vtuple -> ('a wtype, 'tl) structure =
    fun vt -> vt
```
---
User written code is desired as below.

---
**Code 4-5**: Desired user code and generated code
```ocaml
let str1_t = structure (i8_t, i16_t)
val str1_t : i8 ityp wtype * i16 ityp wtype

(* Codes below are generated and applied *)
let _structure_2 : 'a wtype * 'b wtype -> 'a wtype * 'b wtype = 
    fun a -> a
let str1_t = _structure_2 (i8_t, i16_t)
```
And for accessing an element inside,
```ocaml
let str1e0_t = str_nth str1 0
(* => val str1e0_t : i8 ityp wtype *)
(* Codes below are generated and applied *)
let _str2_e0 : 'a * 'b -> 'a = fun (a, b) -> a
let str1e0_t : i8 ityp wtype = _str2_e0 str1_t
```
---

In cases of generating C code in later phases,
the function for outputing C `struct` declaration could be written as below.

---
**Code 4-6**: C-style `struct` declaration output function
```ocaml
let str_decl : ('a wtype, 'tl) structure -> string =
fun wtstr ->
    let rec gen_term : ?n:int -> ('a wtype, 'tl) structure -> string =
    fun ?(n=0) str -> 
        match str with
        | Wtuple.empty -> ""
        | wthd @:: wttl -> Printf.sprintf "%s v%d;\n" (typename wthd) n
            ^ gen_term ~n:n+1 wttl 
    in
    let str_id = get_num () in
    Printf.sprintf "struct Ws_%d {\n%s\n};" str_id @@ gen_term wtstr
```
---

So that generating the declaration of `struct` in **Code 4-5** is designed as below.

---
**Code 4-7**: Generated `str_decl` function
```ocaml
let str1_decl = str_decl str1_t
```
```c
/* Generated String */
struct Ws_0 {
    int8_t v0;
    int16_t v1;
};
```
```ocaml
(* Generated OCaml Code *)
let _str_decl_2 : i8 ityp wtype * i16 ityp wtype -> string =
fun wtstr ->
    let gen_term : ?n:int -> i8 ityp wtype * i16 ityp wtype -> string =
    fun ?(n=0) (v0,v1) ->
        Printf.sprintf "%s v%d;\n" (typename v0) n ^
        Printf.sprintf "%s v%d;\n" (typename v1) (n+1)
    in
    let str_id = get_num () in
    Printf.sprintf "struct Ws_%d {\n%s\n};" str_id @@ gen_term wtstr
```
---

Memo of an example for a flexible tuple implementation? in (OCaml+alpha).
```ocaml
type ('a, 'tl) vt = 'a @* ('tl vt)

let rec nth : ('a, 'tl) vt -> int -> 'elemtyp =
fun vtuple n ->
match vtuple with
| Vtuple.empty  -> failwith "out of bound"
| vthd @:: vttl -> if n = 0 then vthd 
                   else nth vttl (n-1)

let a : int * float * bool * int = (1, 2.9, true, 0);;
let b = nth a 1
val b : float = 2.9

let _nth_ifbi_0 : int * float * bool * int -> int =
fun (v0,v1,v2,v3) -> v0
let _nth_ifbi_1 : int * float * bool * int -> float =
fun (v0,v1,v2,v3) -> v1
```
---